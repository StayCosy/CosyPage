---
layout: post
title:  JVM内存模型
categories: jvm
comments: true
---
>JVM学习之路...

JVM参数与容器硬件限制的关系

最近在一次项目的压测中发现在满负荷持续性疲劳测试时每隔2-3小时容器便会自动重启，经过排查后发现是JVM参数设置不当引起
1）首先想到的是资源的使用超过了容器的硬限制，于是便取了java core进行分析，发现在容器被kill前的内存使用正常，中间的GC次数和GC后内存回收都正常，这时查看JVM大小时2048M，容器硬限制内存设置的参数时2096M，猜想是不是容器在被kill前没有触发FULL GC，同时内存达到了2096M
2）获取到K8S的容器监控日志，显示容器被回收的原因时OOM-KILL，确实时内存超了硬限制
3）JVM 堆空间没有泄露，但是却超过了2096M限制，这个时候开始怀疑时直接内存使用存在泄露或者当前设置的48M无法满足需求，考虑项目中使用了DUBBO框架，涉及NIO等会用直接内存进行buffer存储的操作，并且压测的方式确实是使用RPC方式进行访问，于是估算了下决定调大100M
4）压测后发现容器还是会出现OOM-KILL，于是直接调大1G再次进行疲劳测试，发现容器没有在重启，稳定运行12小时后取java core进行分析发现内存使用稳定在2360M，并且GC后内存回收正常，回想原先调大的100M发现确实不够，需要300M的缺口。
5）为什么会用到这么多的直接内存，感觉似乎哪里存在问题，本期项目中并没有额外引入其他NIO等需要直接内存的操作
6）再次查看JVM参数，发现-XMS=1024,-XMX=2048,找到问题原因：原先一直以为JVM大小是2048M，其实时堆空间的大小是2048M，但是JVM的栈、方法区等空间没有设置参数，所以当交易并非数不高时，堆空间并内有占用全部的2048M空间，栈和方法区可以共享剩下的内存，但是当交易满负荷运行时，堆空间占用不断变大，栈和方法取可用内存逐渐变小，当达到一个临界值时堆并未进行GC，而整个JVM内存已经耗尽全部的内存时，变会发生OOM-KILL现象
7）总结容器内的JVM参数设置需要额外考虑硬限制机制，即：
   a.容器内存资源已经耗尽，应用程序报出OOM报警前K8S会提前回收重启容器，这就有可能隐藏掉应用在内存使用中存在的问题或者性能上存在的问题。
   b.JVM的堆空间参数-XMX应该与硬限制保持1:1.5左右的关系
   c.应用内涉及spring等大量加强类操作的需考虑预留充分的JVM方法区空间
8）网上关于JVM参数和容器硬限制设置的建议

![image1]({{ site.url }}/downloads/image/jvm/2.jpg)
